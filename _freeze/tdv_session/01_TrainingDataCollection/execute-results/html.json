{
  "hash": "9001a771b2fe240d77a6206ddc15760e",
  "result": {
    "markdown": "---\ntitle: \"Collection of training data for remote sensing model building\"\nsubtitle: \"Tutorial: EON Summer School 2024\"\nauthor: Paul Magdon, University of Applied Sciences and Arts (HAWK)\ndate: \"2024-08-27\"\nknitr:\n  opts_chunk: \n    eval: false\neditor_options: \n  chunk_output_type: console\n---\n\n\n# Setup & Installation\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(sf)\nlibrary(RStoolbox)\nlibrary(terra)\nlibrary(ggplot2)\nlibrary(mapview)\nlibrary(kableExtra)\nlibrary(dplyr)\nlibrary(rprojroot)\nlibrary(patchwork)\nlibrary(rmarkdown)\n```\n:::\n\n\n# Data\n\nIn this tutorial we will work with a Sentinel-2 scene from 18/06/2022 from the\nNational Park, Harz. We will also use the boundary of the National Park to\ndefine our study area. Before we can start you may download the S2 Scene from\nthe following link:\n[S2-download](https://cloud.hawk.de/index.php/s/Sn2f8bg8GQEqJXR/download/S2B_MSIL2A_20220618T102559_N0400_R10_resampled_harz_np.tif).\nPlace this file into the data folder of this tutorial. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create a string containing the current working directory\nwd=paste0(find_rstudio_root_file(),\"/tdv_session/data/\")\n\n#Import the boundary of the n\nnp_boundary = st_transform(st_read(paste0(wd,\"nlp-harz_aussengrenze.gpkg\")),25832)\n\ns2  <- terra::rast(paste0(wd,\"S2B_MSIL2A_20220618T102559_N0400_R10_resampled_harz_np.tif\"))\n\nnames(s2)<-c('blue','green','red','vnir1','vnir2','vnir3','nir1','nir2','swir')\n\ns2 <-terra::mask(s2,np_boundary)\n```\n:::\n\n\n# Anaylsing the spectral variablity within the study area\n\n\nIf we have no access to prior information on our target variable in the study\narea we can use the spectral variability as a proxy for the variability of the\ntarget variable. By using the spectral variability as a sampling criterion we \nalso ensure, that we cover the spectral range with our sampling.\n\n## Dimension reduction (PCA)\n\nIn a fist step we reduce the dimensions of the 9 Sentinel-2 bands while \nmaintaining most of the information, using a principal component analysis (PCA).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calculation of the principlal components using the RStoolbox\npca<-RStoolbox::rasterPCA(s2,nSamples = 5000, spca=TRUE )\n\n\n# Extracting the first three components\nrgb_raster <- subset(pca$map, 1:3)\n\n# Function to scale the pixel values to 0-255\nscale_fun <- function(x) {\n  # Calculation of the 2% and 98% quantile\n  q <- quantile(x, c(0.02, 0.98), na.rm = TRUE)\n  \n  # scaling the values\n  x <- (x - q[1]) / (q[2] - q[1]) * 255\n  \n  # restrict the values to 0-255\n  x <- pmin(pmax(x, 0), 255)\n  \n  return(x)\n}\n\n# Scaling of each band\nfor (i in 1:3) {\n  rgb_raster[[i]] <- app(rgb_raster[[i]], scale_fun)\n}\n\n# Plot the first three principal components as RGB\nplotRGB(rgb_raster, r = 1, g = 2, b = 3)\n\n# Show importance of componentes\nsummary(pca$model)\n```\n:::\n\n\n\nFrom the output of the PCA we see that we can capture 92% of the variability\nwith the first two components. Thus we will only use the PC1 and PC2 for the \nsubsequent analysis.\n\n## Unsupervised clustering\n\nIn the next step we run an unsupervised classification of the PC1 and PC2 to get\na clustered map. For the unsupervised classification we need to take a decision\non the number of classes/clusters to be created. Here we will take $n=5$ classes.\nHowever, depending on the target variable this value need to be adjusted.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(2222)\ncluster <- RStoolbox::unsuperClass(pca$map[[c('PC1','PC2')]], nSamples = 100, nClasses = 5, nStarts = 5)\n\n\n## Plots\ncolors <- rainbow(5)\nplot(cluster$map, col = colors, legend = TRUE, axes = TRUE, box =TRUE)\n```\n:::\n\n\nThe map shows a clear spatial patterns related to the elevation, tree species\nand vitality status of the Nationalpark forests.\n\n# Create a stratified sample\n\nIn the next step we take a stratified random sample with $n=10$ points from each\nof the 5 spectral classes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Draw a stratified random sample from the raster\nsamples <- terra::spatSample(cluster$map, size=10, method = \"stratified\",\n                             na.rm = TRUE, xy = TRUE, cells = TRUE)\n# convert to sf object\nsf_samples <- sf::st_as_sf(samples, coords = c(\"x\", \"y\"),crs = 25832)\n\n# convert the classes to factors\nsf_samples$class_unsupervised <- as.factor(sf_samples$class_unsupervised)\n\n# Show map using ggplot\nggplot()+geom_sf(data = np_boundary,fill=NA)+\ngeom_sf(data = sf_samples,aes(color = as.factor(class_unsupervised)), size = 0.5) +\n  scale_color_manual(values = rainbow(5), name = \"Class Unsupervised\") +\n  ggtitle(\"Stratified Random Sample for Training\") +\n  theme_minimal()+\n  coord_sf(crs = st_crs(25832))\n```\n:::\n\n\nWe can now print the sample plot list as following:\n\n\n\n```{.r .cell-code}\nkableExtra::kable(samples[c('x','y','class_unsupervised')], caption='Training plot list') %>%\n  kable_styling(fixed_thead = T) %>% scroll_box(height = \"400px\")\n```\n\n\n## Implement a plot design\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a training data set by extracting the mean value of all pixels touching\n# a buffered area with 13m around the plot center\nplots <- sf::st_buffer(sf_samples,dist = 13)\ntrain<-terra::extract(s2,plots,fun='mean',bind=FALSE,na.rm=TRUE)\n\nplots <- plots %>% mutate(ID=row_number())\ntrain <- plots %>% left_join(train, by= \"ID\")\nmapview::mapview(train, zcol=\"class_unsupervised\",\n        map.types = c(\"Esri.WorldShadedRelief\", \"OpenStreetMap.DE\"))+\n  mapview(np_boundary,alpha.regions = 0.2, aplha = 1)\n```\n:::\n\n\n# Compare the pixel value range between the sample and the image\n\n\n::: {.cell}\n\n```{.r .cell-code}\nimage.sample <- terra::spatSample(s2, size = 100000, method = \"random\", as.df = TRUE)\nimage.sample$group<-'image'\n\ntrain.df<- train[,names(s2)]\ntrain.df <- sf::st_drop_geometry(train.df)\ntrain.df$group<-'train'\n\ndf <- rbind(image.sample,train.df)\n\nblue <-ggplot(df, aes(blue,fill=group)) + theme_classic()+\n        geom_histogram(\n        aes(y=after_stat(density)),alpha=0.2, color='gray80',\n        position='identity',bins=30)\n\ngreen <-ggplot(df, aes(green,fill=group)) + theme_classic()+\n        geom_histogram(\n        aes(y=after_stat(density)),alpha=0.2, color='gray80',\n        position='identity',bins=30)\n\nnir1<-ggplot(df, aes(nir1,fill=group)) + theme_classic()+\n      geom_histogram(\n      aes(y=after_stat(density)),alpha=0.2, color='gray80',\n      position='identity',bins=30)\n\nswir<-ggplot(df, aes(swir,fill=group)) + theme_classic()+\n      geom_histogram(\n      aes(y=after_stat(density)),alpha=0.2, color='gray80',\n      position='identity',bins=30)\n\nblue+green+nir1+swir+plot_layout(ncol=2)\n```\n:::\n",
    "supporting": [
      "01_TrainingDataCollection_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}